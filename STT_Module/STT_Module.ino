// The firmware is developed based on the source code from Speech-to-Text - Deepgram (https://github.com/techiesms/Speech-to-Text---Deepgram) 
// The firmware has been modified to store audio data in the ESP's flash memory.
// By created a local API using Python that integrates a Speech-to-Text API and the Gemini API. This setup allows the ESP to easily connect to the local server and receive responses generated by Gemini.
// For detailed information and the source code used to build the API, please visit: https://github.com/Michla4th/AI-Voice-Assistant/STT-GEMINI-API

#define VERSION           "\n============== AI Voice Assistant Module (last update: Mar 23, 2025) ==============\n" 

#include <WiFi.h>         
#include "FS.h"
#include <LittleFS.h>
#include <EEPROM.h>
#include <Audio.h>        
#include "Wire.h"

#include <WiFiClientSecure.h>
#include <ESPAsyncWebServer.h>
#include <ESPAsyncWiFiManager.h> 
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <BluetoothSerial.h>

// #if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
// #error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
// #endif

// BluetoothSerial SerialBT;

DNSServer dns;
AsyncWebServer server(80);
AsyncWiFiManager wifiManager(&server,&dns);

#include <Ticker.h>
Ticker ticker;

// --- PRIVATE credentials -----    
const char* OPENAI_KEY =  ""
const char* Gemini_Token = "";
const char* Gemini_Max_Tokens = "";
                                                                               
// define 
#define AUDIO_FILE        "/Audio.wav"
#define WELCOME_FILE      "/Welcome.wav"

#define TTS_GOOGLE_LANGUAGE   "en-US"

#define I2C_SDA 13
#define I2C_SCL 12
#define I2C_SLAVE_ADDRESS 0x52
#define EEPROM_ADDR 0

TwoWire I2C = TwoWire(0);
uint8_t rec = 0xFF;
volatile uint8_t request = 0xFF;

// --- PIN assignments ---------
#define pin_I2S_DOUT      21  
#define pin_I2S_LRC       19
#define pin_I2S_BCLK      18

#define pin_RECORD_BTN    14 
#define LED_RECORD        15 
#define LED_STT           4 
#define LED_BLINK         2

// --- global Objects ----------
String text;
String filteredAnswer = "";
String speech = "";
static String serverName  = "Your Speech to Text + Gemini API ";
String serverPath = "/upload"; 

Audio audio_play;

bool    I2S_Record_Init(); 
bool    Record_Start( String filename ); 
bool    Record_Available( String filename, float* audiolength_sec ); 

String  SpeechToText_Deepgram( String filename );
void    Deepgram_KeepAlive();

void SaveIPToEEPROM() {
    char serverIP[64];  
    serverName.toCharArray(serverIP, sizeof(serverIP));  
    EEPROM.put(EEPROM_ADDR, serverIP);
    EEPROM.commit();
}

void LoadIPFromEEPROM() {
    char serverIP[64];  
    EEPROM.get(EEPROM_ADDR, serverIP);
    serverName = String(serverIP);
}

// WiFi connection setup
void connectWiFi() {
    wifiManager.setDebugOutput(false);
    bool res = wifiManager.autoConnect("STT Module");

    if(!res) {
        Serial.println("Failed to connect");
        // ESP.restart();
    } 
    else {  
        WiFi.softAPdisconnect(true);
        WiFi.softAP(WiFi.localIP().toString() + " STT Module", "");

        ticker.detach();
        digitalWrite(LED_BLINK, LOW);
    }
}

void blink()
{
  int state = digitalRead(LED_BLINK);
  digitalWrite(LED_BLINK, !state);
}

void onReceive(int len)
{
  while(I2C.available())
  {
    rec = I2C.read();
    //Serial.println("Byte receive: " + (String)rec);
  }  
}

void onRequest()
{
  I2C.write(request);
}

// ------------------------------------------------------------------------------------------------------------------------------
void setup() 
{   
  // Initialize serial communication
  Serial.begin(115200); 
  Serial.setTimeout(100);
  EEPROM.begin(512); 

  // Pin Led blink
  pinMode(LED_BLINK, OUTPUT);
  pinMode(LED_RECORD, OUTPUT);
  pinMode(LED_STT, OUTPUT);

  digitalWrite(LED_STT, LOW);
  digitalWrite(LED_BLINK, LOW);
  digitalWrite(LED_RECORD, LOW);

  // Pin assignments:
  pinMode(pin_RECORD_BTN, INPUT_PULLUP );

  Serial.println( VERSION );  

  // I2C init
  I2C.begin((uint8_t)I2C_SLAVE_ADDRESS, I2C_SDA, I2C_SCL, 100000);
  I2C.onReceive(onReceive);
  I2C.onRequest(onRequest);

  // Connecting to WLAN
  ticker.attach(0.5, blink);
  connectWiFi();
  // EnterIP();

  //Disable Bluetooth
  btStop();

  // Init LittleFS
  Serial.println("Mounting LittleFS");
  if (!LittleFS.begin(true)) 
  {
    Serial.println("LittleFS Mount Failed");
    return;
  }
  Serial.println("LittleFS Mounted Successfully");

  // initialize I2S

  I2S_Record_Init();  
  audio_play.setPinout( pin_I2S_BCLK, pin_I2S_LRC, pin_I2S_DOUT);
  audio_play.setVolume(20);      

  if (WiFi.status() == WL_CONNECTED){
    // Audio audio_play;
    audio_play.connecttospeech("WiFi Connected, i am kulbot, i am ready to take your commands", TTS_GOOGLE_LANGUAGE);

    while (audio_play.isRunning()) 
    { 
      audio_play.loop();  
    }    
  }
  
  Serial.println("KULBOT Ready");
  Serial.println(" > HOLD button for recording AUDIO .. RELEASE button for REPLAY & transcription" );  
}


// ------------------------------------------------------------------------------------------------------------------------------
void loop() 
{   
  // Check wifi connection
  if (WiFi.status() == WL_CONNECTED) 
  {
  here:
    //-------------------------START RECORDING-------------------------//
    if (/* digitalRead(pin_RECORD_BTN) == LOW || */ rec == 0x01)     
    { 
      digitalWrite(LED_RECORD, HIGH);
      // I2S_Record_Init();
      delay(30);
      //Start Recording
      if (audio_play.isRunning())
      {  
        audio_play.connecttohost("");
      }
      Record_Start(AUDIO_FILE);
      // I2S_Record_DeInit();     
    }
    //-------------------------END RECORDING-------------------------//


    if ( /*digitalRead(pin_RECORD_BTN) == HIGH || */ rec == 0x02)
    { 
      rec == 0xFF;
      digitalWrite(LED_RECORD, LOW);
      float recorded_seconds; 
      if (Record_Available( AUDIO_FILE, &recorded_seconds ))
      { 
        //-------------------------START SPEECH TO TEXT - DEEPGRAM-------------------------//
        if ( recorded_seconds > 0.4 )
        {
          String transcription="";

          File file = LittleFS.open( AUDIO_FILE , "r");  
          if (!file) {
            Serial.println("ERROR - Failed to open file for reading");
          }
          size_t fileSize = file.size();

          WiFiClientSecure client;
          client.setInsecure();

          if (client.connect(serverName.c_str(), 443)) {
            Serial.println("Connection successful!");    
            String head = "--SpeechToText\r\nContent-Disposition: form-data; name=\"file\"; filename=\"audio.wav\"\r\nContent-Type: audio/wav\r\n\r\n";
            String tail = "\r\n--SpeechToText--\r\n";

            uint32_t audioLen = fileSize;
            uint32_t extraLen = head.length() + tail.length();
            uint32_t totalLen = audioLen + extraLen;
          
            client.println("POST " + serverPath + " HTTP/1.1");
            client.println("Host: " + serverName);
            client.println("Content-Length: " + String(totalLen));
            client.println("Content-Type: multipart/form-data; boundary=SpeechToText");
            client.println();
            client.print(head);
          
            const size_t bufferSize = 1024;      // best values seem anywhere between 1024 and 2048; 
            uint8_t buffer[bufferSize];
            size_t bytesRead;
            while (file.available()) 
            { bytesRead = file.read(buffer, sizeof(buffer));
              if (bytesRead > 0) {client.write(buffer, bytesRead);}   // sending WAV AUDIO data       
            }
            file.close();
            client.print(tail);

            int TIMEOUT = 5;
            uint32_t t_wavbodysent = millis();  
            transcription = "";   // waiting until available() true and all data completely received
            while ( transcription == "" && millis() < (t_wavbodysent + TIMEOUT*1000) )   
            { while (client.available())                         
              { char c = client.read();
                transcription += String(c);      
              }
              // printing dots '.' each 100ms while waiting response 
              Serial.print(".");  delay(100);  
              int state = digitalRead(LED_STT);
              digitalWrite(LED_STT, !state);         
            } 
            Serial.println("");
            digitalWrite(LED_STT, LOW);  

            if (millis() >= (t_wavbodysent + TIMEOUT * 1000))
            { 
              Serial.print("\n*** TIMEOUT ERROR - forced TIMEOUT after " + (String) TIMEOUT + " seconds");  
            } 

            client.stop();
          }

          else {
            String getBody = "Connection to " + serverName +  " failed.";
            Serial.println(getBody);
          }

          extractTranscription(transcription);

          if (speech == "") 
          {
            //--------------------START TEXT TO SPEECH--------------------//
            request = 0x01; // action shaking head
            audio_play.connecttospeech( "Sorry, I can't hear you, Please say it again", TTS_GOOGLE_LANGUAGE);

            while (audio_play.isRunning())  
            {
              audio_play.loop();
            }
            //--------------------END TEXT TO SPEECH--------------------//
            goto here;
          }

          
          //--------------------START TEXT TO SPEECH--------------------//
          if (filteredAnswer != "")
          {
            // send request to Kulbot
            if (strstr(speech.c_str(), "hi") != NULL || strstr(speech.c_str(), "Hi") != NULL) {
              request = 0x02; // action waving hand
            } 
            else if (strstr(speech.c_str(), "dancing") != NULL || strstr(speech.c_str(), "Dancing") != NULL){
              request = 0x03; // action dance
              goto here;
            }
            else {
              request = 0x04; // action talking
            }
            // Start speaking
            Serial.print("Gemini speaking: ");
            Serial.println(filteredAnswer);

            audio_play.connecttospeech( filteredAnswer.c_str(), TTS_GOOGLE_LANGUAGE);

            while (audio_play.isRunning())
            { 
              audio_play.loop();  
            }

            speech = "";
            filteredAnswer = "";
          }
          //--------------------END TEXT TO SPEECH--------------------//
        }
      }      
    }

    audio_play.loop();  

    if(rec == 0x03){
      rec == 0xFF;
      audio_play.connecttospeech("Please, don't cover my eyes", TTS_GOOGLE_LANGUAGE);
      while (audio_play.isRunning())  
      {
        audio_play.loop();
      }
    }
  }

  // Run offline mode
  else {

  }
}

void EnterIP(){
  WiFiClient client;
  LoadIPFromEEPROM();
  //SerialBT.begin("SST Module");

  if (client.connect(serverName .c_str(), 5000)) {
    Serial.println("Connection successful!");
    //SerialBT.println("Connection successful!");
  }
  else {
    Serial.println("Can not connect to server");
    Serial.println("Enter Server IP");

    //SerialBT.println("Can not connect to server");
    //SerialBT.println("Enter Server IP");
    while(true){
      String serverIP = "";
      if (Serial.available()){ //|| SerialBT.available()) {
        if(Serial.available())   serverIP = Serial.readStringUntil('\n');
        //if(SerialBT.available()) serverIP = SerialBT.readStringUntil('\n');

        serverIP.trim();

        int dotCount = 0;
        for (char c : serverIP) {
            if (c == '.') dotCount++;
        }

        if (dotCount == 3) {
            Serial.print("Server IP: ");
            Serial.println(serverIP);

            //SerialBT.print("Server IP: ");
            //SerialBT.println(serverIP);

            serverName = serverIP;
            SaveIPToEEPROM();

            if (client.connect(serverName .c_str(), 5000)) {
              Serial.println("Connection successful!");
              //SerialBT.println("Connection successful!");
              break;
            }
            else {
              String getBody = "Connection to " + serverName +  " failed.";
              Serial.println(getBody);
              //SerialBT.println(getBody);
            }
        } else {
            Serial.println("Invalid IP! Please re-enter. (EX: 192.168.1.100)");
            //SerialBT.println("Invalid IP! Please re-enter. (EX: 192.168.1.100)");
            serverIP = "";
        }
      }
    }
  }
}

void extractTranscription(String response) {
    int jsonStartIndex = response.indexOf("{");
    int jsonEndIndex = response.lastIndexOf("}");

  if (jsonStartIndex != -1 && jsonEndIndex != -1) {
    String jsonPart = response.substring(jsonStartIndex, jsonEndIndex + 1);
    // Serial.println("Clean JSON:");
    // Serial.println(jsonPart);

    DynamicJsonDocument doc(1024);  // Increase size if needed
    DeserializationError error = deserializeJson(doc, jsonPart);

    if (error) {
      Serial.print("DeserializeJson failed: ");
      Serial.println(error.c_str());
      return;
    }

    // Speech
    if (doc.containsKey("Speech")) {
      text = doc["Speech"].as<String>();
      text.trim();
      text.replace("\n", "");
      Serial.print("Speech: ");
      Serial.println(text);
      speech = "";
      for (size_t i = 0; i < text.length(); i++) {
        char c = text[i];
        if (isalnum(c) || isspace(c) || c == ',' || c == '.' || c == '\'') {
          speech += c;
        } else {
          speech += ' ';
        }
      }
    }

    // Gemini
    if (doc.containsKey("transcription")) {
      text = doc["transcription"].as<String>();
      text.trim();
      text.replace("\n", "");
      // Serial.print("Extracted Text: ");
      // Serial.println(text);
      filteredAnswer = "";
      for (size_t i = 0; i < text.length(); i++) {
        char c = text[i];
        if (isalnum(c) || isspace(c) || c == ',' || c == '.' || c == '\'') {
          filteredAnswer += c;
        } else {
          filteredAnswer += ' ';
        }
      }
    }
    else {
      Serial.println("No 'candidates' field found in JSON response.");
    }
  } 
  else {
    Serial.println("No valid JSON found in the response.");
  }

}

// ------------------------------------------------------------------------------------------------------------------------------
